\documentclass[12pt, a4paper]{article}

\usepackage[utf8]{inputenc} 
\usepackage[brazil]{babel}   
\usepackage{geometry} 
\usepackage[T1]{fontenc}

\geometry{
    a4paper,
    left=3cm,
    right=2cm,
    top=3cm,
    bottom=2cm
}

\title{Brute-Force Password Cracking}
\author{
  Pedro Kury Kitagawa\\
  \texttt{DRE:123375522}
  \and
  Pedro Freitas de Moura\\
  \texttt{DRE: 123126096}
  \and
  Rafael Oliveira Chaffin\\
  \texttt{XXXXXXXXXXXX}
}

\date{Relatório Parcial \\ Programação Concorrente (ICP-361) - 2025/2}

\begin{document}

\maketitle
\thispagestyle{empty}

\section{Descrição do problema geral}
O problema geral do ataque de força bruta de senhas em hash consiste em descobrir a senha original (texto plano) a partir do seu valor de hash. Dado um valor de hash, o atacante tenta gerar todas as combinações possíveis de caracteres, aplicando a mesma função de hash a cada combinação e comparando o resultado com o hash alvo. Se um hash gerado for igual ao hash alvo, a senha original correspondente é encontrada. Este processo é computacionalmente intensivo, especialmente para senhas longas e complexas, pois o espaço de busca de todas as combinações possíveis cresce exponencialmente.

A entrada para o programa sequencial é uma string de 32 caracteres representando o valor MD5 de uma senha que queremos descobrir. A saída é uma a string original que gerou a string MD5.

O algoritmo concorrente ganha desempenho sobre o algoritmo sequencial neste cenário devido à natureza paralelizável do problema. Em um algoritmo sequencial, a busca por senhas é realizada uma combinação após a outra, utilizando um único fio de execução (thread) ou processo. No entanto, o processo de gerar uma combinação de senha, calcular seu hash e comparar com o hash alvo é independente para cada combinação.

Essa execução paralela permite que múltiplas combinações de senhas sejam testadas ao mesmo tempo, reduzindo significativamente o tempo total necessário para encontrar a senha, especialmente em sistemas com múltiplos núcleos de processamento. O ganho de desempenho é diretamente proporcional ao número de núcleos ou fios de execução disponíveis e à capacidade de distribuir a carga de trabalho de forma eficiente entre eles.

\section{Projeto da solução concorrente}
Para descobrir a string original, não podemos simplesmente reverter o resultado de uma função hash, dado o seu funcionamento. Portanto, dada uma string $hashmd5(x)$, queremos descobrir $x'$ tal que $hashmd5(x')=hashmd5(x)$ e consequentemente $x = x'$ 

Nesse contexto, teremos um conjunto de strings de comprimento $N$, tal que $1 \leq N \leq M$, onde cada string será testada atomicamente, sem depender de outro resultado. Como cada teste é independente, é possível dividir o problema em subconjuntos e delegá-los à diferentes threads, a fim de ganhar o desempenho supracitado.

Repare que aqui caímos em uma situação onde o tempo de execução pode ser muito alto. A string alvo pode ser qualquer conjunto de caracteres pré-determinados, portanto estamos considerando apenas as letras maiúsculas e minúsculas (52 caracteres), os números (10 caracteres) e 33 caracteres especiais. No total, teremos 95 caracteres e $95^{M}$ senhas possíveis. Se $M$ for muito grande, o tempo de execução aumenta em 95 vezes a cada incremento de $M$, causando um grande tempo de execução. Então, fixaremos $M=10$.

A fim de reduzir o tempo de execução, utilizaremos a análise de frequência de comprimento de senhas publicado em um trabalho do pesquisador Mark Vainer. O objetivo é elencar senhas com comprimentos mais frequentes para serem testadas primeiro. Para isso, podemos utilizar documentos de senhas antigas vazadas (a famosa \texttt{rockyou.txt}) com o intuito de testar o desempenho.

Além disso, utilizaremos CUDA para paralelizar o processamento e tentar ganhar desempenho usando as threads de uma GPU.

\section{Casos de teste de corretude e desempenho}
\begin{itemize}
    \item \textbf{Corretude:} A fim de atestar a corretude, escolhemos 5 palavras arbitrárias e faremos o MD5 hash de cada uma delas. Usando a string que representa o hash como entrada, o programa deve retornar a string representando a palavra original como explicitadas abaixo:
    \begin{center}
    \begin{tabular}{ |c|c| } 
     \hline
     Input & Output esperado \\
     \hline
     cce36d2833156c007b1c6c644828ad37 & c0r1nTh14n \\
     c3284ef15aa75f96b0945f19dad4b71f & senhaL3g@l \\
     94f4eee8528d877893b0cd27f42d1a67 & x\_s3nh@\_x \\
     80e58b2df5e73db726074346775494d8 & @@28122004 \\
     b21f91d078060d5f655f5e8b5381f8a3 & mostarda  \\
     \hline
    \end{tabular}

    \end{center}
    
    \item \textbf{Desempenho:} A fim de verficar o desempenho, utilizaremos a mesma entrada do programa sequencial para o programa concorrente sem a análise de frequência e o programa concorrente implementando a análise. Também iremos comparar o tempo de CPU sem threads concorrentes, threads concorrentes somente de uma CPU, e o uso de threads de uma CPU e uma GPU. Faremos o mesmo teste repetidas vezes para as mesmas entradas e calcularemos a média do tempo de execução.
\end{itemize}

\begin{thebibliography}{9}
    \bibitem{exemplo}
    VAINER, M. \textit{Password Dataset Generation for Further Analysis by Machine Learning Methods}.


\end{thebibliography}

\end{document}

